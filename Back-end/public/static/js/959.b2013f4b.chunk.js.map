{"version":3,"file":"static/js/959.b2013f4b.chunk.js","mappings":"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","sources":["Places/Pages/UpdatePlaces.jsx","Shared/Components/FormElements/Input.jsx","Shared/Components/hooks/useHook.js","Shared/Utils/validators.js"],"sourcesContent":["import React, { useContext, useEffect, useState } from \"react\";\r\nimport { useHistory, useParams } from \"react-router-dom/cjs/react-router-dom.min\";\r\nimport Input from \"../../Shared/Components/FormElements/Input\";\r\nimport { VALIDATOR_REQUIRE, VALIDATOR_MINLENGTH } from \"../../Shared/Utils/validators\";\r\nimport \"./Place-form.css\"\r\nimport Button from \"../../Shared/Components/FormElements/Button\";\r\nimport useForm from \"../../Shared/Components/hooks/useHook\";\r\nimport Card from \"../../Shared/Components/UIElements/Card\";\r\nimport useHttpClient from \"../../Shared/Components/hooks/http-hook\";\r\nimport LoadingSpinner from \"../../Shared/Components/FormElements/LoadingSpinner\";\r\nimport ErrorModal from \"../../Shared/Components/FormElements/ErrorModal\";\r\nimport AuthContext from \"../../Shared/Context/AuthContext\";\r\n\r\nconst UpdatePlaces = (props) => {\r\n  const placeId = useParams().placeId;\r\n  const {isLoading, error, sendRequest, clearError} = useHttpClient();\r\n  const[identifiedPlace, setIdentifiedPlace] = useState()\r\n  const history = useHistory();\r\n  const{userId, token} = useContext(AuthContext)\r\n  \r\n  /*\r\n    setFormData -  \r\n    What if the network request comes late\r\n    We cannot initialize a hook in a fetch block\r\n    So we will create an UpdatePlace method for useForm\r\n    Initialize form with dummy values and then update them later.\r\n  */\r\n \r\n const [formState, inputHandler, setFormData] = useForm({\r\n   title : {\r\n     value: \"\",\r\n     isValid: true\r\n    }, \r\n    description : {\r\n      value: \"\",\r\n      isValid: true\r\n    }\r\n  }, false)\r\n  \r\n  /*\r\n    If you set the form directly\r\n    useForm will internally update its State.\r\n    Since we are subscribed to that state, this page reloads.\r\n    Again, calling setForm into a while loop.\r\n  \r\n    Below is Aux to prevent, page reload when setting state.\r\n  */\r\n  useEffect(() => {\r\n   const send = async() => {\r\n    /* Fetch the particular place details.*/\r\n    try {\r\n      const responseData = await sendRequest(`${process.env.REACT_APP_BACKEND_URL}/places/${placeId}`)\r\n      setIdentifiedPlace(responseData.result)\r\n      setFormData({\r\n        title : {\r\n          value: responseData.result.title,\r\n          isValid: true\r\n         }, \r\n         description : {\r\n           value: responseData.result.description,\r\n           isValid: true\r\n         }\r\n       }, true)\r\n    }catch(error){}\r\n   } \r\n   send();\r\n }, [placeId, setFormData, sendRequest])\r\n \r\n if(isLoading) {\r\n  return (\r\n    <div className=\"center\">\r\n      <LoadingSpinner asOverlay/>\r\n    </div>\r\n  ) \r\n} \r\n\r\n  if(!identifiedPlace && !error && !isLoading){\r\n    return (\r\n        <div className = \"center\">\r\n          <Card>\r\n              <h2>Could not find place!</h2>\r\n          </Card>\r\n        </div>\r\n    )\r\n  }\r\n\r\n  /* \r\n  router.patch(\"/:pid\",\r\n    [\r\n        check(\"title\").not().isEmpty(),\r\n        check(\"description\").isLength({min:5}),\r\n    ],\r\n    placesControllers.updatePlaceById) \r\n  */\r\n\r\n  /*\r\n   We send the Form State data because this store\r\n   handles change to Place Information\r\n   Identified Place is only for Form Population\r\n  */\r\n  const placeSubmitHandler = (event) => {\r\n    event.preventDefault()\r\n\r\n    const send = async() => {\r\n      let body = {title : formState.inputs.title.value, description : formState.inputs.description.value}\r\n      try {\r\n        const responseData = await sendRequest(`${process.env.REACT_APP_BACKEND_URL}/places/${placeId}`,\"PATCH\", \r\n          JSON.stringify(body) , \r\n          {\r\n            'Content-Type': 'application/json',\r\n            'Accept': 'application/json',\r\n            'Authorization': 'Bearer ' +  token,\r\n          });\r\n          // console.log(responseData)\r\n        history.push(`/${userId}/places`)\r\n      } catch(error) {}\r\n    }\r\n    send()   \r\n  }\r\n    // const sendRequest = useCallback(async(url, method = \"PATCH\",body = null, headers = {}\r\n \r\n  return (\r\n    <React.Fragment>\r\n    <ErrorModal error = {error} onClear = {clearError} />\r\n    {!isLoading && identifiedPlace && <form className = \"place-form \" onSubmit = {placeSubmitHandler}>\r\n        <Input \r\n            element=\"input\" \r\n            id= \"title\"\r\n            type=\"text\" \r\n            label=\"Title\" \r\n            validators = {[VALIDATOR_REQUIRE()]}\r\n            onInput = {inputHandler}\r\n            errorText = \"Please enter a valid title\"\r\n            value = {identifiedPlace.title}\r\n            validity = {true}\r\n            />\r\n        <Input \r\n            element=\"textarea\" \r\n            id= \"description\"\r\n            type=\"text\" \r\n            label=\"Description\" \r\n            validators = {[VALIDATOR_MINLENGTH(5)]}\r\n            onInput = {inputHandler}\r\n            errorText = \"Please enter a longer address\"\r\n            value = {identifiedPlace.description}\r\n            validity = {true}\r\n            /> \r\n        <Button type = \"submit\">\r\n            Update Place\r\n        </Button> \r\n    </form>}\r\n    </React.Fragment>\r\n  ); \r\n};\r\n\r\nexport default UpdatePlaces;\r\n","import React, { useEffect, useReducer } from \"react\";\r\nimport \"./Input.css\"\r\nimport {validate} from \"../../Utils/validators\"\r\n\r\nconst inputReducer = (state, action) => {\r\n    switch(action.type) {\r\n        case \"CHANGE\" : \r\n            return {...state, \r\n                /* \r\n                    Overall validation of our individual component\r\n                    Is doing using this aux validate function within Validation.js\r\n                */\r\n                value : action.value, isValid: validate(action.value, action.validators)\r\n            }\r\n        /* \r\n            To prevent, first time validity check\r\n        */    \r\n        case \"TOUCHED\" : \r\n        return {...state, isTouched: action.isTouched}   \r\n        default :  \r\n            return state\r\n    }\r\n}\r\n\r\nconst Input = (props) => {\r\n    const[inputState,dispatch] = useReducer(inputReducer,\r\n        {\r\n            value: props.value || \"\", \r\n            isTouched: false, \r\n            isValid: props.validity || \"\"\r\n        }\r\n    )\r\n    \r\n    /* Change in Input, Push to Store */\r\n    const changeHandler = (event) => {\r\n        dispatch({type : \"CHANGE\",\r\n             value : event.target.value,\r\n             validators : props.validators\r\n            }\r\n        )\r\n    }\r\n    /* \r\n        For not showing an error the first time.\r\n    */\r\n    const blurHandler = (event) => {\r\n        dispatch({type : \"TOUCHED\",\r\n            isTouched : true\r\n           }\r\n       )\r\n    } \r\n\r\n    /* \r\n        If input prop type\r\n            input then small input\r\n            else render a Text Area. \r\n    */\r\n    const element =\r\n        props.element ===\"input\" ? (\r\n            <input id={props.id} type={props.type}\r\n             placeholder={props.placeholder}\r\n             value = {inputState.value}\r\n             onChange = {changeHandler}\r\n             onBlur={blurHandler}\r\n             />\r\n        ) : (\r\n            <textarea id={props.id} rows={props.rows || 3}\r\n             value = {inputState.value}\r\n             onChange = {changeHandler}\r\n             onBlur={blurHandler}\r\n            />\r\n        );\r\n    \r\n    const{id, onInput} = props\r\n    const{value,isValid} = inputState\r\n\r\n    /* On input pass to parent Form State*/\r\n    useEffect(() => {\r\n        onInput(id, value, isValid)\r\n    }, [onInput,value,isValid])\r\n  \r\n  return (\r\n    <div className={`form-control ${!inputState.isValid && inputState.isTouched && 'form-control--invalid'}`}>\r\n        <label htmlFor={props.id}>{props.label}</label>\r\n            {element}\r\n            {!inputState.isValid && inputState.isTouched && \r\n            <p>{props.errorText}</p>}\r\n    </div>\r\n    );\r\n};\r\n\r\nexport default Input;\r\n","import React, { useCallback, useReducer } from \"react\";\r\n\r\n/* \r\n  Idea behind Form Hook is to \r\n  Check validity of entire Inputs\r\n\r\n  Internally uses Reducer for two way binding.\r\n    Child sends parent value and validity\r\n    We pass back state as value to input.\r\n\r\n    UseForm uses UseReducer for Entire form (All Inputs)\r\n      Input uses UseReducer for Entire Input\r\n*/\r\n\r\nconst formReducer = (state, action) => {\r\n    switch(action.type) {\r\n      /* Recompute Entire Form Validity */\r\n      case \"INPUT_CHANGE\": \r\n        let formIsValid = true;\r\n        /*\r\n          Loop through all the isValid fields within Inputs\r\n          Create a final is Form Valid Field.\r\n        */\r\n        for(const inputID in state.inputs){\r\n          /* If active element then add to inputs */\r\n          if(inputID === action.inputID){\r\n            formIsValid = formIsValid && action.isValid\r\n          } else {\r\n            /* If inactive, keep old state */\r\n            formIsValid = formIsValid && state.inputs[inputID].isValid\r\n          }\r\n        }\r\n        return {\r\n          /*\r\n            All Previous State Variables, \r\n            If we add anything in the future\r\n          */\r\n          ...state, \r\n         inputs : {\r\n          /* \r\n            All input items we have\r\n          */\r\n          ...state.inputs,\r\n          /* \r\n            Find the Appropriate input Type, update its value.\r\n            title : {value : newValue, isValid: newValue}\r\n          */\r\n          [action.inputID]  : {value : action.value, isValid: action.isValid}\r\n        },\r\n        /* Entire Form Validity */\r\n          isValid : formIsValid\r\n      }\r\n\r\n      case \"SET_DATA\": \r\n        return {\r\n          inputs : action.inputs,\r\n          isValid : action.formIsValid\r\n        }\r\n      /* If action does not match, Return old state */\r\n      default : \r\n        return {...state}\r\n    }\r\n}\r\n\r\n/*\r\n useHook does not accept props, but takes in argument\r\n Remember, this is a Hook.\r\n*/\r\n\r\nconst useForm = (InitialInput, InitialValidity) => {\r\n    const [formState,dispatch] = useReducer(formReducer, {\r\n        inputs: InitialInput,\r\n        /* For entire form */\r\n        isValid:InitialValidity\r\n    });\r\n\r\n    /* \r\n      Value changed in input, \r\n      Push to Global Store and \r\n      Recompute Global Validity.\r\n    */\r\n    const inputHandler = useCallback((id, value, isValid) => {\r\n        const eventType = \"INPUT_CHANGE\"\r\n        const inputID = id\r\n        dispatch({type: eventType, inputID, value, isValid})\r\n    },[]);\r\n\r\n    /* To set once, network request is resolved */\r\n    const setFormData =  useCallback((inputData, formValidity) => {\r\n      const eventType = \"SET_DATA\"\r\n      dispatch({eventType, inputs : inputData, formIsValid : formValidity})\r\n    },[])\r\n  \r\n  //Returning Initial State and Set Method for our Custom Hook\r\n  return [formState, inputHandler, setFormData];\r\n};\r\n\r\nexport default useForm;\r\n\r\n","const VALIDATOR_TYPE_REQUIRE = 'REQUIRE';\nconst VALIDATOR_TYPE_MINLENGTH = 'MINLENGTH';\nconst VALIDATOR_TYPE_MAXLENGTH = 'MAXLENGTH';\nconst VALIDATOR_TYPE_MIN = 'MIN';\nconst VALIDATOR_TYPE_MAX = 'MAX';\nconst VALIDATOR_TYPE_EMAIL = 'EMAIL';\nconst VALIDATOR_TYPE_FILE = 'FILE';\n\nexport const VALIDATOR_REQUIRE = () => ({ type: VALIDATOR_TYPE_REQUIRE });\nexport const VALIDATOR_FILE = () => ({ type: VALIDATOR_TYPE_FILE });\nexport const VALIDATOR_MINLENGTH = val => ({\n  type: VALIDATOR_TYPE_MINLENGTH,\n  val: val\n});\nexport const VALIDATOR_MAXLENGTH = val => ({\n  type: VALIDATOR_TYPE_MAXLENGTH,\n  val: val\n});\nexport const VALIDATOR_MIN = val => ({ type: VALIDATOR_TYPE_MIN, val: val });\nexport const VALIDATOR_MAX = val => ({ type: VALIDATOR_TYPE_MAX, val: val });\nexport const VALIDATOR_EMAIL = () => ({ type: VALIDATOR_TYPE_EMAIL });\n\n/* \n  We call validate when there is a change in value.\n  Within Input Component, Which gets a isValid Boolean. From the function below\n\n  Value - Value of UseReducer State -> Numbers/Strings\n  Validators -> [VALIDATOR_REQUIRE(), VALIDATOR_FILE()]\n             -> [{type: VALIDATOR_TYPE_REQUIRE},{type: VALIDATOR_TYPE_FILE},{type: VALIDATOR_TYPE_EMAIL}]\n*/\nexport const validate = (value, validators) => {\n  let isValid = true;\n  for (const validator of validators) {\n    if (validator.type === VALIDATOR_TYPE_REQUIRE) {\n      isValid = isValid && value.trim().length > 0;\n    }\n    if (validator.type === VALIDATOR_TYPE_MINLENGTH) {\n      isValid = isValid && value.trim().length >= validator.val;\n    }\n    if (validator.type === VALIDATOR_TYPE_MAXLENGTH) {\n      isValid = isValid && value.trim().length <= validator.val;\n    }\n    if (validator.type === VALIDATOR_TYPE_MIN) {\n      isValid = isValid && +value >= validator.val;\n    }\n    if (validator.type === VALIDATOR_TYPE_MAX) {\n      isValid = isValid && +value <= validator.val;\n    }\n    if (validator.type === VALIDATOR_TYPE_EMAIL) {\n      isValid = isValid && /^\\S+@\\S+\\.\\S+$/.test(value);\n    }\n  }\n  return isValid;\n};\n"],"names":["props","placeId","useParams","isLoading","error","sendRequest","clearError","useHttpClient","identifiedPlace","setIdentifiedPlace","useState","history","useHistory","userId","token","useContext","AuthContext","formState","inputHandler","setFormData","useForm","title","value","isValid","description","useEffect","async","responseData","concat","process","result","send","_jsx","className","children","LoadingSpinner","asOverlay","Card","_jsxs","React","ErrorModal","onClear","onSubmit","event","preventDefault","body","inputs","JSON","stringify","push","Input","element","id","type","label","validators","VALIDATOR_REQUIRE","onInput","errorText","validity","VALIDATOR_MINLENGTH","Button","inputReducer","state","action","validate","isTouched","inputState","dispatch","useReducer","changeHandler","target","blurHandler","placeholder","onChange","onBlur","rows","htmlFor","formReducer","formIsValid","inputID","InitialInput","InitialValidity","useCallback","inputData","formValidity","eventType","VALIDATOR_TYPE_REQUIRE","VALIDATOR_TYPE_MINLENGTH","VALIDATOR_TYPE_MAXLENGTH","VALIDATOR_TYPE_EMAIL","val","VALIDATOR_EMAIL","validator","trim","length","test"],"sourceRoot":""}